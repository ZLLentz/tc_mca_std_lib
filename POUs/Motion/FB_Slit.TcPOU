<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.6">
  <POU Name="FB_Slit" Id="{96cc3dff-2d48-44bb-aac4-147730d312ba}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Slit
VAR_IN_OUT
	Axis1: AXIS_REF; 	// Right/Lower
	Axis2: AXIS_REF;	// Left/Upper
	GapAxis: AXIS_REF;
	CenterAxis: AXIS_REF;
	fbAxis1: FB_DriveVirtual;
	fbAxis2: FB_DriveVirtual;
	fbGapAxis:FB_DriveVirtual;
	fbCenterAxis:FB_DriveVirtual;
	stGap:DUT_FB_DriveVirtualIF;
    stCenter:DUT_FB_DriveVirtualIF;
END_VAR
VAR_INPUT
	bLimitFwd1: BOOL;
	bLimitBwd1: BOOL;
	bLimitFwd2: BOOL;
	bLimitBwd2: BOOL;	
	bEnable: BOOL;
	bReset: BOOL;
	bOverlap: BOOL;	// True = Slits are allowed to overlap and cannot collide
	fMinGap: LREAL;	// in mm
END_VAR
VAR_OUTPUT
	bError: BOOL;
END_VAR
VAR
	fbSetPos1: MC_SetPosition;
	fbSetPos2: MC_SetPosition;
	fbGearInMultiMaster_1: MC_GearInMultiMaster;
	fbGearInMultiMaster_2: MC_GearInMultiMaster;
	fbGearOut1: MC_GearOut;
	fbGearOut2: MC_GearOut;
	EmptyAxis1: AXIS_REF; // Needed for master axis 3 in MC_GearInMultiMaster
	EmptyAxis2: AXIS_REF; // Needed for master axis 4 in MC_GearInMultiMaster
	fbPower1: MC_Power;
	fbPower2: MC_Power;
	nSlitState: INT := -2;
	bReverseCalc: BOOL:=FALSE;
	bEnableGearing: BOOL:=FALSE;
	bDisableGearing: BOOL:=FALSE;
	bCoupleToggleOn1: BOOL;
	bCoupleToggleOn2: BOOL;
	fbCoupleToggleOn1: R_TRIG;
	fbCoupleToggleOn2: R_TRIG;
	fbToggleOn1: R_TRIG;
	fbToggleOn2: R_TRIG;
	fbInitTimer: TON;		// Timer to give axes/encoders time to initialise before enabling	
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Gap interface parameter transfer
//fbGapAxis.En:=stGap.EN;
fbGapAxis.bEnable:=stGap.bEnable;
fbGapAxis.bReset:=stGap.bReset;	
fbGapAxis.bExecute:=stGap.bExecute;	
fbGapAxis.nCommand:=stGap.nCommand;
fbGapAxis.nCmdData:=stGap.nCmdData;
fbGapAxis.fVelocity:=stGap.fVelocity;	
fbGapAxis.fPosition:=stGap.fPosition;
fbGapAxis.fAcceleration:=stGap.fAcceleration;
fbGapAxis.fDeceleration:=stGap.fDeceleration;
fbGapAxis.bJogFwd:=stGap.bJogFwd;
fbGapAxis.bJogBwd:=stGap.bJogBwd;	
//fbGapAxis.bLimitFwd:=stGap.bLimitFwd;
//fbGapAxis.bLimitFwd:=stGap.bLimitFwd;
fbGapAxis.fOverride:=stGap.fOverride;
//fbGapAxis.bHomeSensor:=stGap.bHomeSensor;
fbGapAxis.fHomePosition:=stGap.fHomePosition;
fbGapAxis.nHomeRevOffset:=stGap.nHomeRevOffset;
fbGapAxis.MasterAxis:=stGap.MasterAxis;

stGap.EnO:=fbGapAxis.EnO;
stGap.bEnabled:=fbGapAxis.bEnabled;
//stGap.bBusy:=fbGapAxis.bBusy;
stGap.bBusy:=fbGapAxis.status.HasJob OR fbAxis1.status.HasJob OR fbAxis2.status.HasJob;
stGap.bDone:=fbGapAxis.bDone AND fbAxis1.status.HasBeenStopped AND fbAxis2.status.HasBeenStopped;;
stGap.bError:=fbGapAxis.bError;
stGap.bHomed:=fbGapAxis.bHomed;
stGap.nErrorId:=fbGapAxis.nErrorId;
stGap.nMotionAxisID:=fbGapAxis.nMotionAxisID;
stGap.Status:=fbGapAxis.Status;
//stGap.fActPosition:=fbGapAxis.fActPosition;
stGap.fActPosition:=Axis1.NcToPlc.ActPos-Axis2.NcToPlc.ActPos;
stGap.fActVelocity:=fbGapAxis.fActVelocity;
stGap.fActDiff:=fbGapAxis.fActDiff;
stGap.sErrorMessage:=fbGapAxis.sErrorMessage;
stGap.stAxisStatus:=fbGapAxis.stAxisStatus;

//Status struct for EPICS communication
//These parameters are transferred as a whole struct, included here just in case something should be changed
(*stGap.stAxisStatus.bEnable:=bEnable;
stGap.stAxisStatus.bEnabled:=bEnabled;
stGap.stAxisStatus.bError:=bError;
stGap.stAxisStatus.bExecute:=bExecute;
stGap.stAxisStatus.bHomeSensor:=bHomeSensor;
stGap.stAxisStatus.bJogBwd:=bJogBwd;
stGap.stAxisStatus.bJogFwd:=bJogFwd;
stGap.stAxisStatus.bLimitBwd:=bLimitBwd;
stGap.stAxisStatus.bLimitFwd:=bLimitFwd;
stGap.stAxisStatus.bReset:=bReset;
stGap.stAxisStatus.fAcceleration:=fAcceleration;
stGap.stAxisStatus.fActDiff:=fActDiff;*)
//stGap.stAxisStatus.fActPosition:=fActPosition;
stGap.stAxisStatus.fActPosition:=Axis1.NcToPlc.ActPos-Axis2.NcToPlc.ActPos;
(*stGap.stAxisStatus.fActVelocity:=fActVelocity;
stGap.stAxisStatus.fDeceleration:=fDeceleration;
stGap.stAxisStatus.fOverride:=fOverride;
stGap.stAxisStatus.fPosition:=fPosition;
stGap.stAxisStatus.fVelocity:=fVelocity;
stGap.stAxisStatus.nCmdData:=nCmdData;  //Or nCmdDataLocal
stGap.stAxisStatus.nCommand:=nCommand;  //Or nCommandLocal
stGap.stAxisStatus.nErrorId:=nErrorId;
stGap.stAxisStatus.bBusy:=bBusy;
stGap.stAxisStatus.bHomed:=bHomed;*)

//**********************************************************************************//

// Center interface parameter transfer
//fbCenterAxis.En:=fbCenterAxis.En;
fbCenterAxis.bEnable:=stCenter.bEnable;
fbCenterAxis.bReset:=stCenter.bReset;	
fbCenterAxis.bExecute:=stCenter.bExecute;	
fbCenterAxis.nCommand:=stCenter.nCommand;
fbCenterAxis.nCmdData:=stCenter.nCmdData;
fbCenterAxis.fVelocity:=stCenter.fVelocity;	
fbCenterAxis.fPosition:=stCenter.fPosition;
fbCenterAxis.fAcceleration:=stCenter.fAcceleration;
fbCenterAxis.fDeceleration:=stCenter.fDeceleration;
fbCenterAxis.bJogFwd:=stCenter.bJogFwd;
fbCenterAxis.bJogBwd:=stCenter.bJogBwd;
//fbCenterAxis.bLimitFwd:=fbCenterAxis.bLimitFwd;
//fbCenterAxis.bLimitFwd:=fbCenterAxis.bLimitFwd;
fbCenterAxis.fOverride:=stCenter.fOverride;
//fbCenterAxis.bHomeSensor:=stCenter.bHomeSensor;
fbCenterAxis.fHomePosition:=stCenter.fHomePosition;
fbCenterAxis.nHomeRevOffset:=stCenter.nHomeRevOffset;
fbCenterAxis.MasterAxis:=stCenter.MasterAxis;

//Bit 1 and bit 2 of the control word to the nc axis defines whether feed direction is possible or not (do not change manually, done by the power block)
//Axis1.PlcToNc.ControlDWord.1

stCenter.EnO:=fbCenterAxis.EnO;
stCenter.bEnabled:=fbCenterAxis.bEnabled;
//stCenter.bBusy:=fbCenterAxis.bBusy;
stCenter.bBusy:=fbCenterAxis.status.HasJob OR fbAxis1.status.HasJob OR fbAxis2.status.HasJob;
stCenter.bDone:=fbCenterAxis.bDone AND fbAxis1.status.HasBeenStopped AND fbAxis2.status.HasBeenStopped;
stCenter.bError:=fbCenterAxis.bError;
stCenter.bHomed:=fbCenterAxis.bHomed;
stCenter.nErrorId:=fbCenterAxis.nErrorId;
stCenter.nMotionAxisID:=fbCenterAxis.nMotionAxisID;
stCenter.Status:=fbCenterAxis.Status;
//stCenter.fActPosition:=fbCenterAxis.fActPosition;
stCenter.fActPosition:=(Axis1.NcToPlc.ActPos+Axis2.NcToPlc.ActPos)/2;
stCenter.fActVelocity:=fbCenterAxis.fActVelocity;
stCenter.fActDiff:=fbCenterAxis.fActDiff;
stCenter.sErrorMessage:=fbCenterAxis.sErrorMessage;
stCenter.stAxisStatus:=fbCenterAxis.stAxisStatus;

//Status struct for EPICS communication
//These parameters are transferred as a whole struct, included here just in case something should be changed
(*stCenter.stAxisStatus.bEnable:=bEnable;
stCenter.stAxisStatus.bEnabled:=bEnabled;
stCenter.stAxisStatus.bError:=bError;
stCenter.stAxisStatus.bExecute:=bExecute;
stCenter.stAxisStatus.bHomeSensor:=bHomeSensor;
stCenter.stAxisStatus.bJogBwd:=bJogBwd;
stCenter.stAxisStatus.bJogFwd:=bJogFwd;
stCenter.stAxisStatus.bLimitBwd:=bLimitBwd;
stCenter.stAxisStatus.bLimitFwd:=bLimitFwd;
stCenter.stAxisStatus.bReset:=bReset;
stCenter.stAxisStatus.fAcceleration:=fAcceleration;
stCenter.stAxisStatus.fActDiff:=fActDiff;*)
//stCenter.stAxisStatus.fActPosition:=fActPosition;
stCenter.stAxisStatus.fActPosition:=(Axis1.NcToPlc.ActPos+Axis2.NcToPlc.ActPos)/2;
(*stCenter.stAxisStatus.fActVelocity:=fActVelocity;
stCenter.stAxisStatus.fDeceleration:=fDeceleration;
stCenter.stAxisStatus.fOverride:=fOverride;
stCenter.stAxisStatus.fPosition:=fPosition;
stCenter.stAxisStatus.fVelocity:=fVelocity;
stCenter.stAxisStatus.nCmdData:=nCmdData;  //Or nCmdDataLocal
stCenter.stAxisStatus.nCommand:=nCommand;  //Or nCommandLocal
stCenter.stAxisStatus.nErrorId:=nErrorId;
stCenter.stAxisStatus.bBusy:=bBusy;
stCenter.stAxisStatus.bHomed:=bHomed;*)

//**********************************************************************************//

// Collision avoidance
IF NOT bOverlap THEN
	IF Axis1.Nctoplc.SetPos <= (fMinGap+Axis2.NcToPlc.ActPos) 
	OR Axis1.Nctoplc.ActPos <= (fMinGap+Axis2.NcToPlc.ActPos) THEN	
		fbPower1(
		Axis:= Axis1, // Better way to do this?
		Enable:= fbAxis1.bEnable,  // Better way to do this?
		Enable_Positive:= fbAxis1.bEnable AND fbAxis1.bLimitFwd,
		Enable_Negative:= FALSE, 
		Override:= , 
		BufferMode:= , 
		Options:= , 
		Status=> , 
		Busy=> , 
		Active=> , 
		Error=> , 
		ErrorID=> );
	END_IF

	IF Axis2.Nctoplc.SetPos <= (fMinGap+Axis1.NcToPlc.ActPos)
	OR Axis2.Nctoplc.ActPos <= (fMinGap+Axis1.NcToPlc.ActPos) THEN
		fbPower2(
		Axis:= Axis2, 
		Enable:= fbAxis2.bEnable, // Better way to do this?
		Enable_Positive:= fbAxis2.bEnable AND fbAxis2.bLimitFwd, // Better way to do this?
		Enable_Negative:= FALSE, 
		Override:= , 
		BufferMode:= , 
		Options:= , 
		Status=> , 
		Busy=> , 
		Active=> , 
		Error=> , 
		ErrorID=> );	
	END_IF
END_IF

//**********************************************************************************//

fbToggleOn1(CLK:= fbGapAxis.bExecute);
fbToggleOn2(CLK:= fbCenterAxis.bExecute);

IF bEnable AND (fbToggleOn1.Q OR fbToggleOn2.Q) THEN
	nSlitState:=2;
	bReverseCalc:=FALSE;
	bDisableGearing:=FALSE;
END_IF

IF bEnable AND NOT bReset THEN	
	CASE nSlitState OF
		-2:
			IF GapAxis.Status.Operational AND CenterAxis.Status.Operational THEN
				stGap.bEnable:=TRUE;
				stCenter.bEnable:=TRUE;					
				nSlitState:=nSlitState+1;				
			END_IF
		-1:
			fbInitTimer(IN:= TRUE, PT:= T#1S, Q=> , ET=> );
			IF fbInitTimer.Q THEN
				fbAxis1.bEnable:=TRUE;
				fbAxis2.bEnable:=TRUE;
				nSlitState:=nSlitState+1;
			END_IF
		0: 	
			bReverseCalc:=TRUE;
			bDisableGearing:=FALSE;
			nSlitState:=nSlitState+1;
		1: 
			IF fbSetPos1.Done AND fbSetPos2.Done THEN
				bReverseCalc:=FALSE;
				nSlitState:=nSlitState-1;	
			END_IF
		2:
			bEnableGearing:=TRUE;		
			nSlitState:=nSlitState+1;
		3:
			IF fbGearInMultiMaster_1.InGear AND fbGearInMultiMaster_2.InGear THEN
				nSlitState:=nSlitState+1;
			END_IF
		4: 
			IF GapAxis.Status.HasJob OR CenterAxis.Status.HasJob THEN
				nSlitState:=nSlitState+1;				
			END_IF
		5:
			IF GapAxis.Status.InTargetPosition AND CenterAxis.Status.InTargetPosition AND Axis1.Status.NotMoving AND Axis2.Status.NotMoving THEN
				bEnableGearing:=FALSE;
				nSlitState:=nSlitState+1;
			END_IF
		6:
			bDisableGearing:=TRUE;
			nSlitState:=nSlitState+1;
		7:
			bDisableGearing:=FALSE;
			nSlitState:=0;
	END_CASE
ELSE
	bEnableGearing:=FALSE;
	bDisableGearing:=TRUE;
	nSlitState:=-2;
END_IF

fbSetPos1(
	Axis:= GapAxis, 
	Execute:= bReverseCalc, 
	Position:= Axis1.NcToPlc.SetPos-Axis2.NcToPlc.SetPos, 
	Mode:= , 
	Options:= , 
	Done=> , 
	Busy=> , 
	Error=> , 
	ErrorID=> );

fbSetPos2(
	Axis:= CenterAxis, 
	Execute:= bReverseCalc, 
	Position:= (Axis1.NcToPlc.SetPos+Axis2.NcToPlc.SetPos)/2, 
	Mode:= , 
	Options:= , 
	Done=> , 
	Busy=> , 
	Error=> , 
	ErrorID=> );

fbGearInMultiMaster_1(
	Master1:= GapAxis, 
	Master2:= CenterAxis, 
	Master3:= EmptyAxis1, 
	Master4:= EmptyAxis2, 
	Slave:= Axis1, 
	Enable:= bEnableGearing, 
	GearRatio1:= 0.5, 
	GearRatio2:= 1, 
	GearRatio3:= , 
	GearRatio4:= , 
	Acceleration:= , 
	Deceleration:= , 
	Jerk:= , 
	BufferMode:= , 
	Options:= , 
	InGear=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorID=> );

fbGearInMultiMaster_2(
	Master1:= GapAxis, 
	Master2:= CenterAxis, 
	Master3:= EmptyAxis1, 
	Master4:= EmptyAxis2, 
	Slave:= Axis2, 
	Enable:= bEnableGearing, 
	GearRatio1:= -0.5, 
	GearRatio2:= 1, 
	GearRatio3:= , 
	GearRatio4:= , 
	Acceleration:= , 
	Deceleration:= , 
	Jerk:= , 
	BufferMode:= , 
	Options:= , 
	InGear=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorID=> );
	
fbGearOut1(
	Slave:= Axis1, 
	Execute:= bDisableGearing, 
	Options:= , 
	Done=> , 
	Busy=> , 
	Error=> , 
	ErrorID=> );
	
fbGearOut2(
	Slave:= Axis2, 
	Execute:= bDisableGearing, 
	Options:= , 
	Done=> , 
	Busy=> , 
	Error=> , 
	ErrorID=> );]]></ST>
    </Implementation>
    <LineIds Name="FB_Slit">
      <LineId Id="737" Count="38" />
      <LineId Id="1075" Count="0" />
      <LineId Id="776" Count="49" />
      <LineId Id="827" Count="16" />
      <LineId Id="1048" Count="0" />
      <LineId Id="1050" Count="0" />
      <LineId Id="1074" Count="0" />
      <LineId Id="1051" Count="22" />
      <LineId Id="1049" Count="0" />
      <LineId Id="846" Count="0" />
      <LineId Id="860" Count="38" />
      <LineId Id="735" Count="1" />
      <LineId Id="948" Count="59" />
      <LineId Id="926" Count="0" />
      <LineId Id="1008" Count="0" />
      <LineId Id="928" Count="19" />
      <LineId Id="927" Count="0" />
      <LineId Id="620" Count="0" />
      <LineId Id="31" Count="20" />
      <LineId Id="9" Count="0" />
      <LineId Id="123" Count="21" />
      <LineId Id="96" Count="0" />
      <LineId Id="1012" Count="0" />
      <LineId Id="1015" Count="15" />
      <LineId Id="1013" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>